
***

## 1. Цель проекта

Создать кроссплатформенный десктопный мессенджер (чат‑приложение), устанавливаемый на компьютеры пользователей, с централизованным хранением данных на отдельном сервере БД и единым backend‑API.

***

## 2. Общая архитектура

Тип архитектуры: многослойная client‑server‑архитектура.

Состав:

1. Клиент:
   - Electron‑приложение (Windows обязательно, по возможности Linux/macOS).
   - UI на HTML/CSS/JavaScript.
   - Взаимодействует только с сервером приложений по HTTP(S)/WebSocket.

2. Сервер приложений (backend):
   - Язык: Python 3.10+.
   - Фреймворк: FastAPI (предпочтительно) или аналогичный.
   - Реализует:
     - REST API для CRUD‑операций.
     - WebSocket для обмена сообщениями в реальном времени.
     - Аутентификацию и авторизацию (JWT).
     - Бизнес‑логику (создание чатов, отправка сообщений, статусы).
   - Развёрнут на отдельном сервере/VPS с публичным доменным именем или IP.

3. Сервер БД:
   - MySQL (5.7+ или 8+).
   - Развёрнут на отдельном сервере или как managed‑решение.
   - Доступен только с серверов приложений (ограничение по IP/Firewall, приватная сеть, VPN).

4. Хранение данных:
   - Все пользователи, чаты и сообщения хранятся централизованно в MySQL.
   - Клиенты не имеют прямого доступа к БД, только через API.

***

## 3. Функциональные требования

### 3.1. Пользователи и аутентификация

Обязательно:
- Регистрация:
  - Поля: username (уникальный), email (опционально, уникальный), пароль.
  - Валидация: длина пароля, формат email, уникальность username/email.
  - Пароли хранятся только в виде безопасных хэшей (bcrypt/argon2).
- Авторизация:
  - Вход по username/email + пароль.
  - Выдача access‑token (JWT) с ограниченным временем жизни.
- Профиль пользователя:
  - Отображаемое имя.
  - Аватар (на первом этапе можно хранить только URL, без загрузки файлов).
  - Дата регистрации.

Расширение (можно заложить в дизайн БД, но не реализовывать сразу):
- Восстановление пароля (через email).
- Статус: онлайн/оффлайн, «был(а) в сети…».

### 3.2. Чаты и сообщения

Минимальный функционал:
- Личные чаты (1‑на‑1).
- Список чатов пользователя (диалоги, упорядоченные по времени последнего сообщения).
- Отправка текстовых сообщений.
- Отображение истории сообщений с пагинацией (по времени/лимиту).
- Метаданные сообщения:
  - Автор (отправитель).
  - Время отправки.
  - Признак принадлежности к конкретному чату.

Дополнительный/расширяемый функционал:
- Групповые чаты:
  - Название чата.
  - Роли участников (участник/админ).
- Статусы сообщений:
  - «Доставлено», «прочитано».
- Отправка файлов:
  - Сохранение файлов на файловом хранилище/объектном сторидже.
  - В БД хранится ссылка/путь и тип файла.

***

## 4. Нефункциональные требования

- Платформы:
  - Обязательно: Windows 10+.
  - По возможности: Linux, macOS.
- Язык интерфейса:
  - Русский, с возможностью добавления других языков (через JSON‑файлы локализации).
- Производительность:
  - Задержка доставки сообщения при стабильном соединении не более 1–2 секунд.
- Устойчивость:
  - При потере соединения клиент должен:
    - Пытаться переподключиться.
    - Досылать неотправленные сообщения после восстановления.
- Масштаб:
  - Базовый этап: до 100 одновременных пользователей.
  - Возможность масштабирования backend и БД в будущем без изменения клиентской части.

***

## 5. Технический стек

### 5.1. Клиент (Electron)

- Electron (Node.js).
- HTML5, CSS3.
- JavaScript (ES6+).
- Допустимо использование UI‑фреймворка (Bootstrap/Tailwind или др.).
- Взаимодействие с API:
  - REST: fetch / axios.
  - WebSocket: встроенный WebSocket API.

Структура клиента (пример):
- main.js
  - Создание главного окна.
  - Загрузка index.html.
  - Настройка меню/иконок.
- /renderer
  - index.html – основной layout.
  - styles.css – стили.
  - app.js – логика UI, навигация, обработка событий.
  - api.js – обёртки над REST‑запросами.
  - ws.js – управление WebSocket‑подключением.
- config (например, config.json)
  - baseUrl API (https://api.example.com).

### 5.2. Backend (Python)

- Python 3.10+.
- FastAPI:
  - REST‑эндпойнты.
  - WebSocket‑подключения.
  - Pydantic‑схемы для валидации.
- Сервер: Uvicorn/Gunicorn.
- Работа с БД:
  - SQLAlchemy или другой ORM.
  - Асинхронный драйвер MySQL (по возможности).
- Аутентификация:
  - JWT (pyjwt или встроенные решения FastAPI).

Структура backend‑проекта (пример):
- app/
  - main.py – точка входа (инициализация FastAPI, роуты).
  - config.py – чтение .env, настройки БД, JWT‑секреты.
  - models.py – ORM‑модели (User, Chat, Message, ChatUser).
  - schemas.py – Pydantic‑схемы (UserCreate, UserOut, ChatOut и т.п.).
  - routes/
    - auth.py – регистрация, логин, /me.
    - users.py – поиск и получение информации о пользователях.
    - chats.py – создание чатов, получение списков.
    - messages.py – работа с сообщениями.
  - services/ – бизнес‑логика.
  - ws.py – WebSocket‑обработчики.
- migrations/ – миграции БД.
- .env – секреты и строки подключения.

### 5.3. База данных (MySQL)

#### Схема БД (минимальная)

Таблица users:
- id (PK, AUTO_INCREMENT)
- username (VARCHAR, UNIQUE)
- email (VARCHAR, UNIQUE, NULLABLE)
- password_hash (VARCHAR)
- display_name (VARCHAR)
- avatar_url (VARCHAR, NULLABLE)
- created_at (DATETIME)

Таблица chats:
- id (PK)
- is_group (BOOLEAN)
- title (VARCHAR, NULLABLE – для групп)
- created_at (DATETIME)

Таблица chat_users:
- chat_id (FK → chats.id)
- user_id (FK → users.id)
- role (ENUM: ‘member’, ‘admin’)
- joined_at (DATETIME)
- PK составной (chat_id, user_id)

Таблица messages:
- id (PK)
- chat_id (FK → chats.id)
- sender_id (FK → users.id)
- content (TEXT)
- created_at (DATETIME)
- is_read (BOOLEAN, по умолчанию FALSE)
- attachment_url (VARCHAR, NULLABLE)

Дополнительно (опционально):
- Таблица refresh_tokens, если внедряется механизм обновления токенов.

***

## 6. API‑интерфейс

Базовый URL: `https://api.<домен>` (для продакшн), `http://localhost:8000` (для разработки).

### 6.1. Аутентификация

- POST /api/auth/register  
  Вход: { username, email?, password }.  
  Выход: данные пользователя и/или access‑token.

- POST /api/auth/login  
  Вход: { username или email, password }.  
  Выход: { access_token, token_type, user }.

- GET /api/auth/me  
  Заголовок: Authorization: Bearer <token>.  
  Выход: данные текущего пользователя.

(Опционально)  
- POST /api/auth/refresh  
  Вход: refresh_token.  
  Выход: новый access_token.

### 6.2. Пользователи

- GET /api/users/search?query=...  
  Поиск пользователей по username/display_name.

- GET /api/users/{id}  
  Публичный профиль пользователя.

### 6.3. Чаты

- POST /api/chats  
  Создание чата.  
  Вход:  
  - Для личного: { type: "direct", user_id }.  
  - Для группового: { type: "group", title, user_ids }.

- GET /api/chats  
  Список чатов текущего пользователя.

- GET /api/chats/{chat_id}  
  Информация о чате (участники, настройки).

### 6.4. Сообщения

- GET /api/chats/{chat_id}/messages?offset=&limit=  
  Получение истории сообщений.

- POST /api/chats/{chat_id}/messages  
  Отправка сообщения.  
  Вход: { content, attachment? }.

- (Опционально) POST /api/chats/{chat_id}/read  
  Пометка сообщений как прочитанных.

### 6.5. WebSocket

- ws(s)://api.<домен>/ws/chat/{chat_id}?token=<JWT>  
  Функционал:
  - Подключение к каналу чата.
  - Отправка сообщения: JSON { type: "message", content: "..." }.
  - Приём широковещательных сообщений для всех участников чата.
  - Возможные типы сообщений:
    - message – новое сообщение.
    - status – пользователь печатает/онлайн.
    - system – служебные уведомления.

***

## 7. Клиентская логика (Electron)

Экраны:
- Экран аутентификации:
  - Форма логина.
  - Ссылка/кнопка регистрации.
- Основное окно:
  - Левая панель: список чатов.
  - Верхняя панель: информация о текущем чате.
  - Центральная область: сообщения.
  - Нижняя панель: поле ввода сообщения, кнопка «Отправить».

Поведение:
- После успешного логина:
  - Сохранение JWT в локальном хранилище (например, в файле настроек, с учётом безопасности).
  - Переход к списку чатов.
- При выборе чата:
  - Загрузка истории сообщений через REST.
  - Установка WebSocket‑соединения для приёма новых сообщений.
- При отправке сообщения:
  - Отправка по WebSocket (основной канал).
  - При отсутствии WebSocket/проблемах – резервно через REST (опционально).
- Обработка ошибок:
  - Отображение понятных сообщений (нет соединения, ошибка сервера и т.п.).
  - Автоматические попытки переподключения.

***

## 8. Безопасность

- Пароли:
  - Не хранятся в открытом виде.
  - Использование современных алгоритмов хеширования (bcrypt/argon2) с солями.
- Токены:
  - JWT с ограниченным сроком жизни (например, 15–60 минут).
  - Опционально: refresh‑токены, хранимые на backend.
- Доступ к API:
  - Все приватные маршруты доступны только при наличии валидного JWT.
  - Проверка прав (например, доступ к чату только участникам).
- Доступ к БД:
  - Сервер MySQL недоступен напрямую из интернета.
  - Подключение только с серверов приложений.
- Защита от атак:
  - Валидация всех входных данных.
  - Параметризованные запросы/ORM для предотвращения SQL‑инъекций.
  - Ограничение размера сообщения и вложений.

***

## 9. Развёртывание и инфраструктура

### 9.1. Базовый этап

- Сервер приложений:
  - Один экземпляр FastAPI, запущенный за Nginx/Apache (reverse proxy).
  - HTTP → HTTPS (TLS) на уровне веб‑сервера.
- MySQL:
  - Один экземпляр БД на отдельном сервере/сервисе.
  - Резервное копирование: ежедневные дампы.
- Конфигурация:
  - Все секреты (строка подключения к БД, JWT_SECRET) в .env.
  - Права доступа к .env только у нужных пользователей.

### 9.2. Масштабирование (на будущее)

- Backend:
  - Несколько инстансов backend‑приложения за балансировщиком (NGINX/HAProxy/Cloud LB).
  - Статические файлы и статику (если есть) можно вынести на CDN.
- БД:
  - Репликация MySQL: master для записи, один или несколько slave для чтения.
  - В будущем – переход на кластерную/managed‑БД при росте нагрузки.
- Кэш:
  - Введение Redis для:
    - Кэширования часто читаемых данных (например, профилей).
    - Хранения сессий/WebSocket‑подключений.
    - Реализации быстрых флагов онлайн‑статуса.

***

## 10. Этапы реализации

1. Аналитика и детализация требований:
   - Уточнение UI/UX макетов.
   - Уточнение дополнительных функций (группы, файлы и т.п.).
2. Проектирование БД:
   - Схема таблиц.
   - Подготовка начальных миграций.
3. Реализация backend (базовый функционал):
   - Регистрация, логин, /me.
   - CRUD чатов и сообщений по REST.
4. Реализация Electron‑клиента (базовый UI):
   - Экран логина.
   - Список чатов.
   - Просмотр и отправка сообщений (пока через REST).
5. Добавление WebSocket:
   - Реальное время в чате.
   - Обработка подключений/отключений.
6. Доработка UX/UI:
   - Обработка ошибок, загрузчики, индикаторы статуса.
7. Тестирование:
   - Юнит‑тесты backend.
   - Интеграционные тесты (клиент + сервер).
8. Подготовка к продакшн:
   - Настройка окружений (dev/test/prod).
   - CI/CD (по возможности).
   - Сборка установщиков Electron‑приложения.

***